---
title: 按键扫描程序
author: lixinghui
date: 2023-5-23 12:00:00 +0800
categories: [mcu]
tags: [mcu]
---


该简易版按键扫描程序支持短按、长按、联合按三个功能，没有对按键抬起做检测。

程序如下：

## `head file`

```c
/*----------------包含头文件----------------*/
#include <stdint.h>

/*----------------按键扫描开始----------------*/
#define USE_SHORT_PRESS 0X01
#define USE_LONG_PRESS 0X02
#define USE_UNION_PRESS 0X04
#define KEY_USE_PRESS (USE_SHORT_PRESS|USE_LONG_PRESS|USE_UNION_PRESS)


#define LONG_PRESS_CNT 50 /*50*10ms=500ms*/

#define KEY_NONE 0X00
#define KEY1_SHORT_PRESS 0X01
#define KEY2_SHORT_PRESS 0X02
#define KEY3_SHORT_PRESS 0X04
#define KEY1_LONG_PRESS 0X10
#define KEY2_LONG_PRESS 0X20
#define KEY3_LONG_PRESS 0X40
#define KEY12_UNION_PRESS 0X03
#define KEY23_UNION_PRESS 0X06
#define KEY13_UNION_PRESS 0X05

/*按键端口配置*/
#define KEY1_READ_PIN() HAL_GPIO_ReadPin(KEY0_GPIO_Port, KEY0_Pin)
#define KEY2_READ_PIN() HAL_GPIO_ReadPin(KEY_UP_GPIO_Port, KEY_UP_Pin)

uint8_t KeyScan(void);

/*----------------按键扫描结束----------------*/
```



## `source file`

```c

/**
 @brief 按键检测，建议每10ms检测一次
 @param none
 @return 按键的状态
*/
uint8_t KeyScan(void)
{
    static uint8_t key_prev_state = 0; /*按键上一状态*/
    static uint16_t key_press_cnt = 0; /*按键时长计数*/
    static uint8_t key_release = 0;    /*1表示释放，0表示未释放，ff为联合按键钳位*/
    uint8_t key_curr_state = 0;        /*按键当前状态*/
    uint8_t ret_val = KEY_NONE;        /*按键返回状态*/

    /*读取按键IO口状态*/
    if (KEY1_READ_PIN() == GPIO_PIN_SET)
    {
        key_curr_state |= 0x01; /*按键1按下*/
    }
    if (KEY2_READ_PIN() == GPIO_PIN_SET)
    {
        key_curr_state |= 0x02;
    }

    /*当前无按键按下*/
    if (key_curr_state == 0)
    {
        /*按键刚刚松开*/
        if (key_prev_state != 0)
        {
            /*消抖*/
            if ((key_press_cnt >= 5) && (key_release != 0xff))
            {
                if ((key_prev_state == 0x01) && (key_press_cnt <= LONG_PRESS_CNT))
                {
                    ret_val = KEY1_SHORT_PRESS;
                }
                else if ((key_prev_state == 0x02) && (key_press_cnt <= LONG_PRESS_CNT))
                {
                    ret_val = KEY2_SHORT_PRESS;
                }
                else if ((key_prev_state == 0x04) && (key_press_cnt <= LONG_PRESS_CNT))
                {
                    ret_val = KEY3_SHORT_PRESS;
                }
#if (KEY_USE_PRESS & USE_LONG_PRESS)
                else if ((key_prev_state == 0x01) && (key_press_cnt > LONG_PRESS_CNT))
                {
                    ret_val = KEY1_LONG_PRESS;
                }
                else if ((key_prev_state == 0x02) && (key_press_cnt > LONG_PRESS_CNT))
                {
                    ret_val = KEY2_LONG_PRESS;
                }
                else if ((key_prev_state == 0x04) && (key_press_cnt > LONG_PRESS_CNT))
                {
                    ret_val = KEY3_LONG_PRESS;
                }
#endif
                else
                {
                    ret_val = KEY_NONE;
                }
            }
            else
            {
                ret_val = KEY_NONE;
            }
            /*清空上一个状态和按键计数*/
            key_prev_state = 0;
            key_press_cnt = 0;
        }
        /*一直无按键*/
        else
        {
            ret_val = KEY_NONE;
        }
        /*标记按键释放*/
        key_release = 1;
    }
    /*当前有按键按下*/
    else
    {
        if (key_release == 1)
        {
            key_release = 0;
        }

        /*当前值和上一个值不一致----当前状态刚按下*/
        if (key_prev_state != key_curr_state)
        {
            key_prev_state = key_curr_state;
            key_press_cnt = 0;
        }
        /*持续按下*/
        else
        {
            key_press_cnt++;
            /*消抖*/
            if (key_press_cnt >= 10)
            {
                if (key_release == 0)
                {
#if (KEY_USE_PRESS & USE_UNION_PRESS)
                    if (key_curr_state == 0x03)
                    {
                        ret_val = KEY12_UNION_PRESS;
                        key_release = 0xff;
                    }
                    else if (key_curr_state == 0x05)
                    {
                        ret_val = KEY13_UNION_PRESS;
                        key_release = 0xff;
                    }
                    else if (key_curr_state == 0x06)
                    {
                        ret_val = KEY23_UNION_PRESS;
                        key_release = 0xff;
                    }
                    else
                    {
                        ret_val = KEY_NONE;
                    }
#endif
                }
                else
                {
                    ret_val = KEY_NONE;
                }
            }
            else
            {
                ret_val = KEY_NONE;
            }
        }
    }
    return ret_val;
}

```



## `example`

```c
		key_status = KeyScan();
        switch (key_status)
        {
        case KEY1_SHORT_PRESS:
            printf("KEY1_SHORT_PRESS\n");
            break;
        case KEY2_SHORT_PRESS:
            printf("KEY2_SHORT_PRESS\n");
            break;
        case KEY1_LONG_PRESS:
            printf("KEY1_LONG_PRESS\n");
            break;
        case KEY2_LONG_PRESS:
            printf("KEY2_LONG_PRESS\n");
            break;
        case KEY12_UNION_PRESS:
            printf("KEY1_2_UNION_PRESS\n");
            break;
        default:
            break;
        }
```

