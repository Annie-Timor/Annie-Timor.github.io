---
title: 数字信号的产生
author: lixinghui
date: 2023-10-6 14:10:00 +0800
categories: [DSP, C语言集]
tags: [DSP_C语言集]
math: true
---

# 常用数字信号的产生

## 1、均匀分布的随机数

**功能：**

产生（a，b）区间上均匀分布的随机数。

**方法简介：**

均匀分布的概率密度函数为：

$$
f(x)=\begin{cases}
 \frac{1}{b-a},& \text a\leq x \leq b \\
 0,& \text 其他
  \end{cases}
$$

通常用 U (a,b)表示。均匀分布的均值为$$\frac{a+b}{2}$$,方差为$$\frac{(a-b)^2}{12}$$。

**代码：**

```c
double uniform(double a, double b, long int *seed);

/**
 * 产生（a，b）区间上平均分布的随机数
 * a ： 	给定区域的下限
 * b ： 	给定区域的上限
 * seed：	*seed为随机数种子
 */
double uniform(double a, double b, long int *seed)
{
    double t;
    *seed = 2045 * (*seed) + 1;
    // *seed = *seed - (*seed / 1048576) * 1048576;
    *seed = *seed % 1048576;
    t = (*seed) / 1048576.0;
    t = a + (b - a) * t;
    return (t);
}

void test_uniform(void)
{
    int i, j;
    double a, b, x;
    long s;
    a = 0.0;
    b = 1.0;
    s = 13579;
    for (i = 0; i < 10; i++)
    {
        for (j = 0; j < 5; j++)
        {
            x = uniform(a, b, &s);
            printf("%13.7f", x);
        }
        printf("\n");
    }
}

/*输出
	0.4826355    0.9895945    0.7206707    0.7715826    0.8864250
    0.7391634    0.5891514    0.8145781    0.8121262    0.7979975
    0.9048367    0.3909597    0.5126686    0.4073076    0.9440937
    0.6716261    0.4753571    0.1051798    0.0926647    0.4993505
    0.1718712    0.4765749    0.5956669    0.1387815    0.8082657
    0.9033289    0.3075924    0.0264425    0.0749702    0.3141527
    0.4423084    0.5207319    0.8967896    0.9346323    0.3230572
    0.6519232    0.1829033    0.0372286    0.1324558    0.8721647
    0.5768661    0.6912775    0.6624966    0.8054800    0.2066078
    0.5129900    0.0645466    0.9977674    0.4344330    0.4154520
*/
```

## 2、正态分布的随机数

**功能：**

产生正态分布$$N(\mu,\sigma^2)$$的随机数

**方法简介：**

正态分布的概率密度函数为：

$$
f(x)=\frac{1}{\sqrt{2\pi\sigma}}e^{-(x-\mu)^2/2\sigma^2}
$$

通常用$$N(\mu,\sigma^2)$$表示，其中$$\mu$$是均值，$$\sigma^2$$是方差，正态分布也称为高斯分布。

**代码：**

```c
/**
 * 产生正太分布的随机数
 * mean :		正态分布的均值
 * sigma ：		正态分布的方差
 * seed ：		*seed为随机数种子
 * return ：	产生的随机数
 */
double gauss(double mean, double sigma, long int *seed)
{
    int i;
    double x, y;

    for (x = 0.0, i = 0; i < 12; i++)
    {
        x += uniform(0.0, 1.0, seed);
    }
    x = x - 6.0;
    y = mean + x * sigma;

    return (y);
}


void test_gauss(void)
{
    int i, j;
    double mean, sigma, x;
    long s;
    mean = 0.0;
    sigma = 1.0;
    s = 13579;
    for (i = 0; i < 10; i++)
    {
        for (j = 0; j < 5; j++)
        {
            x = gauss(mean, sigma, &s);
            printf("%13.7f", x);
        }
        printf("\n");
    }
}

/*输出
    2.8997211   -0.9088573    0.2041950   -0.2572155   -0.8516827
    0.7996998   -0.9866619    0.0431385   -1.9194927    0.2543507
   -0.3689251    1.2145863   -1.0537090    1.7050953   -1.6925945
   -0.4928722    1.9956684   -0.5980663    1.2923298    0.1707630
   -0.5213604   -0.4051342    0.8358479   -0.5445080    1.6452045
    0.5338917   -0.8120403   -0.3886852   -0.2546368    0.4690113
   -0.4013348   -0.1117687   -0.9708843    0.6502247    1.3179646
    0.5362415    0.7464619    1.3275318   -0.4041424    1.8053455
   -0.8525982   -0.2490673    1.6823444    0.9455433    0.4819355
    1.1704273   -0.1725750    0.2068348   -1.9999371    0.8360157
*/
```

## 3、指数分布的随机数

**功能：**

产生指数分布的随机数

**方法简介：**

1、产生均匀分布的随机数$$\mu$$,即$$\mu \sim U(0,1)$$,

2、计算$$x=-\beta ln(\mu)$$

**代码：**

```c
/**
 * 产生指数分布的随机数
 * beta : 		指数分布的均值
 * s ：			*s为随机数种子
 * return ：	返回随机数
 */
double exponent(double beta, long int *s)
{
    double u, x;
    u = uniform(0.0, 1.0, s);
    x = -beta * log(u);
    return (x);
}

void test_exponent(void)
{
    int i, j;
    long int s;
    double x, beta;
    beta = 2.0;
    s = 13579;
    for (i = 0; i < 10; i++)
    {
        for (j = 0; j < 5; j++)
        {
            x = exponent(beta, &s);
            printf(" %13.7f", x);
        }
        printf("\n");
    }
}

/*输出
     1.4569871     0.0209201     0.6551459     0.5186231     0.2411175
     0.6044725     1.0581442     0.4101700     0.4161992     0.4512997
     0.2000017     1.8783014     1.3362513     1.7963731     0.1150597
     0.7961070     1.4873781     4.5041683     4.7575350     1.3888939
     3.5220200     1.4822608     1.0361474     3.9497084     0.4257289
     0.2033371     2.3579596     7.2655633     5.1813279     2.3157521
     1.6314957     1.3050398     0.2178681     0.1352042     2.2598519
     0.8556571     3.3975955     6.5813568     4.0430122     0.2735539
     1.1002900     0.7384279     0.8234798     0.4326338     3.1538658
     1.3349979     5.4807361     0.0044701     1.6674272     1.7567764
*/
```

## 4、拉普拉斯分布的随机数

**功能：**

产生拉普拉斯分布的随机数

**方法简介：**

拉普拉斯分布的概率密度函数为

$$
f(x)=\frac{1}{2\beta}e^{-\frac{|x|}{\beta}}
$$

拉普拉斯分布的均值为0，方差为$$2\beta^2$$，拉普拉斯分布也称为双指数分布。

根据上述的组合算法，产生拉普拉斯分布随机数的方法为:

（1）产生均匀分布的随机数$$u_{1}$$和$$u_2$$，即$$u_1,u_2 \sim U(0,1)$$;

（2）计算$$x=\begin{cases}
 -\beta ln(1-u_2) & \text u_1 \leq 0.5 \\
 \beta ln(u_2) & \text u_1 > 0.5
  \end{cases}$$

**代码：**

```c
/**
 * 产生拉普拉斯分布的随机数
 * beta : 		拉普拉斯分布参数
 * s ：			*s 为随机数种子
 */
double laplace(double beta, long int *s)
{
    double u1, u2, x;

    u1 = uniform(0.0, 1.0, s);
    u2 = uniform(0.0, 1.0, s);
    if (u1 <= 0.5)
    {
        x = -beta * log(1.0 - u2);
    }
    else
    {
        x = beta * log(u2);
    }
    return (x);
}

void test_laplace(void)
{
    int i, j;
    long int s;
    double x, beta;
    beta = 1.5;
    s = 13579;
    for (i = 0; i < 10; i++)
    {
        for (j = 0; j < 5; j++)
        {
            x = laplace(beta, &s);
            printf(" %13.7f", x);
        }
        printf("\n");
    }
}

/*输出
     6.8481253    -0.3889673    -0.4533544    -0.3076275    -0.3384748
    -1.4087260    -1.3472798    -0.5970803     0.1666987     1.0377737
     0.9710420    -2.9622813    -0.1525028     0.0401976     0.5656504
     1.1032428    -0.1014031     1.5829981     0.0569089     3.0855192
    -0.5538209    -0.3244754     1.0792059     9.1569152     0.8053746
    -0.6078966    -1.5382193     0.9028431    -3.4637606     0.2715135
    -0.0907091    -0.9236331    -1.0849801     5.9835590     0.7128560
    -1.7257896     0.1008553    -0.9126053    -0.9336386     1.3214851
    -3.7663899     0.0510632     0.0513326    -0.1540588     1.1192728
     0.7144444    -2.1629963    -0.8393618    -2.9372783    -2.0191079
*/
```

## 5、瑞利分布的随机数

**功能：**

产生瑞利分布的随机数

**方法简介：**

瑞利分布的概率密度函数为

$$
f(x)=\frac{x}{\sigma^2}e^{-x^2/2\sigma^2} \qquad x>0
$$

瑞利分布的均值为$$\sigma \sqrt{\frac{\pi}{2}}$$，方差为$$(2-\frac{\pi}{2})\sigma^2$$。

首先用逆变换法产生参数$$\beta=2$$的指数分布的随机变量y，其概率密度为$$f(y)=\frac{1}{2}e^{-y/2}$$；然后通过变换$$x=\sigma \sqrt{y}$$，产生瑞利分布的随机变量$x$，具体方法如下：

（1）产生均匀分布的随机数$$\mu$$，即$$\mu\sim U(0,1)$$；

（2）计算$$y=-2ln(\mu)$$

（3）计算$$x=\sigma \sqrt{y}$$

**代码：**

```c
/**
 * 产生瑞利分布的随机数
 * sigma : 		瑞利分布的参数
 * s ： 		*s 为随机数种子
 */
double rayleigh(double sigma, long int *s)
{
    double u, x;

    u = uniform(0.0, 1.0, s);
    x = -2.0 * log(u);
    x = sigma * sqrt(x);
    return (x);
}

void test_rayleigh(void)
{
    int i, j;
    long int s;
    double x, sigma;
    sigma = 1.0;
    s = 13579;
    for (i = 0; i < 10; i++)
    {
        for (j = 0; j < 5; j++)
        {
            x = rayleigh(sigma, &s);
            printf(" %13.7f", x);
        }
        printf("\n");
    }
}

/*输出
     1.2070572     0.1446379     0.8094109     0.7201549     0.4910371
     0.7774783     1.0286614     0.6404452     0.6451350     0.6717884
     0.4472155     1.3705114     1.1559633     1.3402884     0.3392045
     0.8922483     1.2195811     2.1223026     2.1811774     1.1785134
     1.8767046     1.2174813     1.0179132     1.9873873     0.6524790
     0.4509292     1.5355649     2.6954709     2.2762530     1.5217595
     1.2773002     1.1423834     0.4667634     0.3677012     1.5032804
     0.9250173     1.8432568     2.5654155     2.0107243     0.5230238
     1.0489471     0.8593183     0.9074579     0.6577490     1.7759127
     1.1554211     2.3410972     0.0668588     1.2912890     1.3254344
*/
```

## 6、对数正态分布的随机数

**功能：**

产生对数正态分布的随机数

**方法简介：**

对数正态分布的概率密度函数为：

$$
f(x)=\begin{cases}
 \frac{1}{x\sqrt{2\pi}\sigma}exp(-\frac{(lnx-\mu)^2}{2\sigma^2}) & \text x > 0 \\
 0 & \text x \leq 0
  \end{cases}
$$

对数正态分布的均值为$$e^{\mu+\sigma^2/2}$$，方差为$$(e^{\sigma^2}-1)e^{2\mu+\sigma^2}$$；

首先产生正态分布的随机变量$$y$$，然后通过变换$$x=e^y$$产生对数正态分布的随机变量$$x$$。具体方法如下：

（1）产生正态分布的随机数$$y$$，即$$y \sim N(\mu,\sigma)$$；

（2）计算$$x=e^y$$

**代码：**

```c
/**
 * 产生对数正太分布的随机数
 * u : 		对数正太分布的参数
 * sigma ：	对数正太分布的参数
 * s ：		*s为随机数种子
 * return 	随机数
 */
double lognorm(double u, double sigma, long int *s)
{
    double x, y;

    y = gauss(u, sigma, s);
    x = exp(y);

    return (x);
}

void test_lognorm(void)
{
    int i, j;
    long int s;
    double x, u, sigma;
    u = 0.0;
    sigma = 0.5;
    s = 13579;
    for (i = 0; i < 10; i++)
    {
        for (j = 0; j < 5; j++)
        {
            x = lognorm(u, sigma, &s);
            printf(" %13.7f", x);
        }
        printf("\n");
    }
}

/*输出
     4.2625202     0.6348105     1.1074915     0.8793188     0.6532200
     1.4916008     0.6105892     1.0218035     0.3829900     1.1356161
     0.8315511     1.8354563     0.5904593     2.3456150     0.4290005
     0.7815813     2.7124010     0.7415348     1.9082086     1.0891325
     0.7705273     0.8166317     1.5188051     0.7616608     2.2764160
     1.3059697     0.6662967     0.8233758     0.8804533     1.2642836
     0.8181845     0.9456485     0.6154250     1.3841861     1.9328243
     1.3075050     1.4524197     1.9420923     0.8170368     2.4661859
     0.6529210     0.8829085     2.3190839     1.6044350     1.2724800
     1.7953745     0.9173305     1.1089542     0.3678910     1.5189326
*/
```

## 7、柯西分布的随机数

**功能：**

产生柯西分布的随机数

**方法简介：**

柯西分布的概率密度函数为：

$$
f(x)=\frac{\beta}{\pi[\beta^2+(x-\alpha)^2]} \qquad \beta>0
$$

通常用$$C(\alpha,\beta)$$表示，其分布函数为：

$$
F(x)=\frac{1}{2}+\frac{1}{\pi}arctg(\frac{x-\alpha}{\beta})
$$

用逆变换方法产生柯西分布的$$C(\alpha,\beta)$$随机变量$$x$$，其具体方法如下：

（1）产生均匀分布的随机数$$u$$，即$$u \sim U(0,1)$$；

（2）计算$$x=\alpha-\frac{\beta}{tg(u\pi)}$$

**代码：**

```c
/**
 * 产生柯西分布的随机数
 * a :		柯西分布的均值
 * b ：		柯西分布的方差
 * s ：		*s为随机数种子
 * return ：	产生的随机数
 */
double cauchy(double a, double b, long int *s)
{
    double u, x;

    u = uniform(0.0, 1.0, s);
    x = a - b / tan(3.1415926 * u);

    return (x);
}

void test_cauchy(void)
{
    int i, j;
    long int s;
    double x, alpha, beta;
    alpha = 1.0;
    beta = 1.0;
    s = 13579;
    for (i = 0; i < 10; i++)
    {
        for (j = 0; j < 5; j++)
        {
            x = cauchy(alpha, beta, &s);
            printf(" %13.7f", x);
        }
        printf("\n");
    }
}

/*输出
     0.9453936    31.5794761     1.8308272     2.1457105     3.6826832
     1.9341286     1.2876380     2.5179655     2.4928073     2.3583287
     4.2446248     0.6433801     1.0398206     0.7002780     6.6349649
     1.5983145     0.9224268    -1.9153867    -2.3374801     0.9979597
    -0.6684446     0.9262747     1.3099350    -1.1463964     2.4543467
     4.1908474     0.3092863   -11.0100979    -3.1670158     0.3393057
     0.8167456     1.0652235     3.9752384     5.8008814     0.3787720
     1.5171594    -0.5444290    -7.5111263    -1.2628045     3.3546694
     1.2462881     1.6854823     1.5600127     2.4274267    -0.3179573
     1.0408319    -3.8636963   143.5732975     0.7910515     0.7279566
*/
```

## 8、韦伯分布的随机数

**功能：**

产生韦伯分布的随机数

**方法简介：**

（1）产生均匀分布的随机数$$u$$，即$$u \sim U(0,1)$$；

（2）计算$$x=\beta (-ln(u))^{1/\alpha}$$

**代码：**

```c
/**
 * 产生韦伯分布的随机数
 * a :		韦伯分布的参数alpha
 * b ：		柯西分布的参数bate
 * s ：		*s为随机数种子
 * return ：	产生的随机数
 */
double weibull(double a, double b, long int *s)
{
    double u, x;

    u = uniform(0.0, 1.0, s);
    u = -log(u);
    x = b * pow(u, 1.0 / a);

    return (x);
}

void test_weibull(void)
{
    int i, j;
    long int s;
    double x, alpha, beta;

    alpha = 2.0;
    beta = 1.0;
    s = 13579;
    for (i = 0; i < 10; i++)
    {
        for (j = 0; j < 5; j++)
        {
            x = weibull(alpha, beta, &s);
            printf("%13.7f", x);
        }
        printf("\n");
    }
}

/*输出
    0.8535183    0.1022744    0.5723399    0.5092264    0.3472157
    0.5497602    0.7273734    0.4528631    0.4561793    0.4750262
    0.3162291    0.9690979    0.8173895    0.9477270    0.2398538
    0.6309148    0.8623741    1.5006946    1.5423253    0.8333348
    1.3270305    0.8608893    0.7197734    1.4052951    0.4613724
    0.3188551    1.0858084    1.9059857    1.6095540    1.0760465
    0.9031876    0.8077870    0.3300516    0.2600040    1.0629798
    0.6540860    1.3033794    1.8140227    1.4217968    0.3698337
    0.7417176    0.6076298    0.6416696    0.4650988    1.2557599
    0.8170061    1.6554057    0.0472763    0.9130792    0.9372237
*/
```

## 9、爱尔朗分布的随机数

**功能：**

产生爱尔朗分布的随机数

**方法简介：**

（1）产生IID均匀分布的随机数$$u_1,u_2,...,u_m$$，即$$u_i \sim U(0,1)$$；

（2）计算$$x=-\beta ln(\prod_{i=1}^{m}u_i)$$

**代码：**

```
/**
 * 产生爱尔朗分布的随机数
 * m :		爱尔朗分布的参数m
 * beta ：	爱尔朗分布的参数bate
 * s ：		*s为随机数种子
 * return ：	产生的随机数
 */
double erlang(int m, double beta, long int *s)
{
    int i;
    double u, x;
    for (u = 1.0, i = 0; i < m; i++)
    {
        u *= uniform(0.0, 1.0, s);
    }
    x = -beta * log(u);

    return (x);
}

void test_erlang(void)
{
    int i, j, m;
    long int s;
    double x, beta;

    m = 3;
    beta = 1.0;
    s = 13579;
    for (i = 0; i < 10; i++)
    {
        for (j = 0; j < 5; j++)
        {
            x = erlang(m, beta, &s);
            printf("%13.7f", x);
        }
        printf("\n");
    }
}

/*输出
    1.0665266    0.6821066    0.9422567    1.2648014    1.6238420
    3.3938267    4.8342244    3.2340583    1.4935128    7.3813217
    1.5772018    1.6253566    7.0109822    1.0561359    2.2049897
    3.4101020    2.2240145    1.9299352    1.9592353    5.9587182
    0.5812231    1.5929523    4.2617919    2.7262666    4.4612183
    1.3056705    1.8735027    9.1363471    4.4265428    1.6808789
    2.2389831    2.5986790    2.9839443    4.1416554    3.6086711
    4.1421739    2.3656100    1.2727489    4.0904192    7.5296684
    4.3179039    2.9108482    2.7557035    2.3836979    1.6895797
    2.4720518    2.0467947    1.7919904    1.5726769    2.3995915
*/
```

## 10、贝努里分布的随机数

**功能：**

产生贝努里分布的随机数

**方法简介：**

贝努里分布的概率函数为：

$$
f(x)=\begin{cases}
 p & \text x = 1 \\
 1-p & \text x = 0
  \end{cases}
$$

用BN($$p$$)表示。贝努里分布的均值为$$p$$，方差为$$p(1-p)$$。

产生贝努里分布的随机变量$$x$$的算法如下：

（1）产生均匀分布的随机数$$u$$，即$$u \sim U(0,1)$$；

（2）如果$$u \leq p$$，那么$$x=1$$；否则，$$x=0$$.

**代码：**

```c
/**
 * 产生贝努里分布的随机数
 * p :		贝努里分布的参数p
 * s ：		*s为随机数种子
 * return ：	产生的随机数
 */
int bn(double p, long int *s)
{
    int x;
    double u;

    u = uniform(0.0, 1.0, s);

    x = (u <= p) ? 1 : 0;

    return (x);
}

void test_bernoulli(void)
{
    int i, j, x;
    long int s;
    double p;

    p = 0.7;
    s = 13579;
    for (i = 0; i < 10; i++)
    {
        for (j = 0; j < 5; j++)
        {
            x = bn(p, &s);
            printf("%13d", x);
        }
        printf("\n");
    }
}

/*输出
            1            0            0            0            0
            0            1            0            0            0
            0            1            1            1            0
            1            1            1            1            1
            1            1            1            1            0
            0            1            1            1            1
            1            1            0            0            1
            1            1            1            1            0
            1            1            1            0            1
            1            1            0            1            1
*/
```

## 11、贝努里-高斯分布的随机数

**功能：**

产生贝努里-高斯分布的随机数。

**方法简介：**

产生贝努里-高斯分布随机数变量$$x$$的算法如下：

（1）产生贝努里分布的随机数$$y$$，即$$y \sim BN(p)$$;

（2）产生高斯分布的随机数$$z$$，即$$z \sim N(\mu , \sigma)$$；

（3）计算$$x=y \times z$$

**代码：**

```c
/**
 * 产生贝努里-高斯分布的随机数
 * p :		贝努里分布的参数p
 * mean :	高斯分布的均值
 * sigma ：	高斯分布的方差
 * s ：		*s为随机数种子
 * return ：	产生的随机数
 */
double bg(double p, double mean, double sigma, long int *s)
{
    double x, u;

    u = uniform(0.0, 1.0, s);

    if (u <= p)
    {
        x = gauss(mean, sigma, s);
    }
    else
    {
        x = 0.0;
    }

    return (x);
}

void test_bg(void)
{
    int i, j;
    long int s;
    double x, p, mean, sigma;

    p = 0.4;
    mean = 0.0;
    sigma = 1.0;
    s = 12357;
    for (i = 0; i < 10; i++)
    {
        for (j = 0; j < 5; j++)
        {
            x = bg(p, mean, sigma, &s);
            printf("%13.7f", x);
        }
        printf("\n");
    }
}

/*输出
    0.6910229    0.0000000    1.6546841    0.0000000    1.4901104
    0.0000000    0.0000000    0.0000000    0.3757915    0.0000000
   -1.0547123    0.0000000    0.0000000    0.0000000    1.1713009
    0.0000000    0.0000000    0.0000000    0.0000000    0.0000000
    0.4781475    0.0000000    0.0000000    0.0000000    0.1607037
    0.9864216    0.0000000    0.7719517    0.0000000    0.0000000
    0.0000000    0.0000000    0.0000000    0.0000000   -0.2416019
    0.8279819    0.0000000    2.7472401   -0.6780338    0.0000000
    0.1726513    0.1959400   -0.1427860    0.2121983   -1.9189777
    0.0000000    0.0000000    0.0000000    0.0000000   -0.9137707
*/
```



## 12、二项式分布的随机数

**功能：**

产生二项式分布的随机数

**方法简介：**

（1）产生IID贝努里分布的随机数$$y_1,y_2,...,y_n$$，即$$y_i \sim BN(p)$$；

（2）计算$$x=\sum_{i=1}^{n}y_i$$

**代码：**

```c
/**
 * 产生二项式分布的随机数
 * n :		二项式分布参数n
 * p :		二项式分布的参数p
 * s ：		*s为随机数种子
 * return ：	产生的随机数
 */
int bin(int n, double p, long int *s)
{
    int i;
    int x;

    for (x = 0.0, i = 0; i < n; i++)
    {
        x += bn(p, s);
    }

    return (x);
}

void test_bin(void)
{
    int i, j, n, x;
    long int s;
    double p;
    n = 5;
    p = 0.7;
    s = 13579;
    for (i = 0; i < 10; i++)
    {
        for (j = 0; j < 5; j++)
        {
            x = bin(n, p, &s);
            printf("%11d", x);
        }
        printf("\n");
    }
}

/*输出
          1          1          3          5          4
          4          3          4          4          4
          5          4          2          4          4
          4          5          3          4          5
          5          4          3          4          5
          4          2          3          4          3
          5          3          3          4          4
          3          3          5          2          2
          2          4          4          4          2
          3          4          3          4          3
*/
```

## 13、泊松分布的随机数

**功能：**

产生泊松分布的随机数

**方法简介：**

产生泊松分布随机变量$$x$$的算法如下：

（1）设$$b=1,i=0$$

（2）产生均匀分布的随机数$$u_i$$，即$$u_i \sim U(0,1)$$

（3）计算$$b\leftarrow bu_i$$

（4）如果$$b \geq e^{-\lambda}$$，那么$$i\leftarrow i+1$$，返回到（2）

（5）取$$x=i$$

**代码：**

```c
/**
 * 产生泊松分布的随机数
 * lambda : 	泊松分布的均值
 * s ：			*s为随机数种子
 * return ：	返回随机数
 */
int poisson(double lambda, long int *s)
{
    int i, x;
    double a, b, u;
    a = exp(-lambda);
    i = 0;
    b = 1.0;
    do
    {
        u = uniform(0.0, 1.0, s);
        b *= u;
        i++;
    } while (b >= a);
    x = i - 1;

    return (x);
}

void test_poisson(void)
{
    int i, j, x;
    long int s;
    double n;

    n = 4.0;
    s = 13579;
    for (i = 0; i < 10; i++)
    {
        for (j = 0; j < 5; j++)
        {
            x = poisson(n, &s);
            printf("%11d", x);
        }
        printf("\n");
    }
}

/*输出
         12          4          2          5          1
          6          1          6          3          5
          3          7          4          1          7
          1          1          5          5          3
          3          2          6          1          3
          3          4          6          6          5
          2          1          7          2          2
          3          0          5          4          3
          4          7          4          3          4
          1          7          3          6          4
*/
```

